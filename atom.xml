<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuWen&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-25T09:47:47.649Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>胡文(Christine Hu)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript学习之四</title>
    <link href="http://yoursite.com/2018/09/14/javascript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B/"/>
    <id>http://yoursite.com/2018/09/14/javascript学习之四/</id>
    <published>2018-09-14T07:24:52.000Z</published>
    <updated>2018-09-25T09:47:47.649Z</updated>
    
    <content type="html"><![CDATA[<h3 id="javascript学习16章（HTML5脚本编程）"><a href="#javascript学习16章（HTML5脚本编程）" class="headerlink" title="javascript学习16章（HTML5脚本编程）"></a><center>javascript学习16章（HTML5脚本编程）</center></h3><hr><h3 id="跨文档消息的传递"><a href="#跨文档消息的传递" class="headerlink" title="跨文档消息的传递"></a>跨文档消息的传递</h3><blockquote><p>简称为XDM,指的是在来自不同域的页面间传递消息</p></blockquote><p>发送：<br>XDM的核心是postMessage方法，该方法接收两个参数：一条消息和一个表示消息接收方来自哪个域的字符串。第二个参数对保障安全通信非常重要。<br>接收：<br>接收到XDM消息时，会触发window对象的message事件。触发message事件后，传递给onmessage处理程序的事件对象包含以下三方面的重要信息。</p><pre><code>function send() {    var data = document.querySelector('#data').value;    window.frames[0].postMessage(data, 'http://localhost:9022/'); // 触发跨域子页面的messag事件}window.addEventListener('message', function(messageEvent) {    var data = messageEvent.data;    console.info('message from child:', data);}, false);</code></pre><hr><h3 id="原生拖放"><a href="#原生拖放" class="headerlink" title="原生拖放"></a>原生拖放</h3><h4 id="拖放事件"><a href="#拖放事件" class="headerlink" title="拖放事件"></a>拖放事件</h4><p>拖放某个元素时，将依次触发下列事件：</p><ul><li>dragstart：拖动开始时，触发dragstart事件</li><li>drag：触发dragstart事件后，随即会触发drag事件，而且在元素被拖动期间会持续触发该事件。</li><li>dragend：当拖动停止时（无论是将元素放到有效的目标，还是放到无效的目标上），会触发dragend事件。</li></ul><p>当某个元素被拖动到一个有效的放置目标上时，下列事件会依次发生：</p><ul><li>dragenter：有元素被拖动放置到目标上，会触发dragenter事件。</li><li>dragover：在被拖动的元素还在放置目标的范围内移动时，就会持续触发该事件。</li><li>dragleave：如果元素被拖出放置目标，dragover不再发生，但会触发dragleave事件。</li><li>drop：元素被放到了防止目标中，则会触发drop事件而不是drapleave事件。</li></ul><h4 id="自定义放置目标"><a href="#自定义放置目标" class="headerlink" title="自定义放置目标"></a>自定义放置目标</h4><p>可以将任何元素变成有效的放置目标，方法就是重写dragenter和dragover事件的默认行为。为了让Firefox支持正常的拖放，还要取消drop事件的默认行为，阻止它打开url:</p><pre><code>var droptarget=document.getElementById("droptarget");EventUtil.addHandler(droptarget,"dragenter",function(event){    EventUtil.preventDefault(event);});EventUtil.addHandler(droptarget,"dragover",function(event){    EventUtil.preventDefault(event);});EventUtil.addHandler(droptarget,"drop",function(event){    EventUtil.preventDefault(event);})</code></pre><h4 id="dataTransfer"><a href="#dataTransfer" class="headerlink" title="dataTransfer"></a>dataTransfer</h4><blockquote><p>事件对象的一个属性，只能在拖放事件事件处理程序中访问dataTransfer对象。</p></blockquote><p>可以在dragstart事件处理程序中，调用setData()，手动保存自己要传输的数据，以便将来使用。<br>保存在dataTransfer对象中的数据只能在drop事件处理程序中读取。</p><p>为了更好的在跨浏览器的情况下从dataTransfer对象中取得数据，最好在取得URL数据时检测两个值，而在取得文本数据时使用Text</p><p><pre><code><br>var dataTransfer=event.dataTransfer;<br>//读取URL<br>var url = dataTransfer.getData(“url”) || dataTransfer.getData(“text/uri-list”);<br>//读取文本<br>var text=dataTransfer.getData(“Text”);<br></code></pre></p><h4 id="dropEffect和effectAllowed"><a href="#dropEffect和effectAllowed" class="headerlink" title="dropEffect和effectAllowed"></a>dropEffect和effectAllowed</h4><blockquote><p>通过它来确定被拖动的元素以及作为放置目标的元素能够接收什么操作。</p></blockquote><p>dropEffect：可以知道被拖动的元素能够执行哪种放置行为（必须在dragenter事件处理程序中针对放置目标来设置它）</p><ul><li>none：不能把拖动的元素放在这里</li><li>move：应该把拖动元素移动到放置目标上</li><li>copy：应该把拖动的元素复制到放置目标</li><li>link：表示放置目标会打开拖动的元素</li></ul><p>effectAllowed：表示允许拖动元素是哪一种dropEffect（必须在dragstart事件处理程序设置effectAllowed属性）</p><ul><li>uninitiallized：没有给拖动元素设置任何放置行为。</li><li>none：被拖动的元素不能有任何行为</li><li>copy：只允许值为“copy”的dropEffect</li><li>link：只允许值为“link”的dropEffect</li><li>move：只允许值为“move”的dropEffect</li><li>copyLink：只允许值为“copy”和“link”的dropEffect</li><li>copyMove：只允许值为“copy”和“move”的dropEffect</li><li>linkMove：只允许值为“link”和“move”的dropEffect</li><li>all：允许任意的dropEffect</li></ul><h4 id="可拖动"><a href="#可拖动" class="headerlink" title="可拖动"></a>可拖动</h4><p>默认情况下，图像、链接和文本是可以拖动的。文本只有在选中的情况下才能拖动，而图像和链接则在任何时候都可以拖动。让其他元素拖动也有可能，为所有的HTML元素规定一个draggable属性，表示元素是否可以拖动。</p><h4 id="其他成员"><a href="#其他成员" class="headerlink" title="其他成员"></a>其他成员</h4><hr><h3 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h3><blockquote><p>HTML5新增了两个与媒体相关的标签，让开发人员不必依赖任何插件就能在网页中嵌入跨浏览器的音频和视频内容。这两个标签就是<audio>和<video></video></audio></p></blockquote><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>见书P487</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>见书P488</p><h4 id="自定义媒体播放器"><a href="#自定义媒体播放器" class="headerlink" title="自定义媒体播放器"></a>自定义媒体播放器</h4><p><pre><code><br>EventUtil.addHandler(player,”canplaythrough”,function(){<br>        var player=document.getElementById(“player”),<br>            btn=document.getElementById(“video-btn”),<br>            curtime=document.getElementById(“curtime”),<br>            duration=document.getElementById(“duration”);<br>        //更新播放时间<br>        duration.innerHTML=player.duration;<br>        //为按钮添加事件处理程序<br>        EventUtil.addHandler(btn,”click”,function(event){<br>            if(player.paused){<br>                player.play();<br>                btn.value=”Paused”;<br>            }else{<br>                player.pause();<br>                btn.value=”Play”;<br>            }<br>        })<br>        //定时更新当前时间<br>        setInterval(function(){<br>            curtime.innerHTML=player.currentTime;<br>        },250)<br>    });<br></code></pre></p><h4 id="检测编解码器的支持情况"><a href="#检测编解码器的支持情况" class="headerlink" title="检测编解码器的支持情况"></a>检测编解码器的支持情况</h4><p>这两个媒体元素都有一个canPlayType()方法，该方法接受一种格式/编解码器字符串（详情见P490），返回”probably”,”maybe”,””。空字串串为假值。</p><h4 id="Audio类型"><a href="#Audio类型" class="headerlink" title="Audio类型"></a>Audio类型</h4><blockquote><p>audio元素还有一个原生的JavaScript构造函数Audio.</p></blockquote><p><pre><code><br>var audio=new Audio(“sound.mp3”);<br>EventUtil.addHandler(audio,”canplaythrough”,function(event){<br>  audio.play();<br>});<br></code></pre></p><hr><h3 id="历史状态管理"><a href="#历史状态管理" class="headerlink" title="历史状态管理"></a>历史状态管理</h3><p>执行pushState后，新的状态信息就会被加入历史状态栈，而浏览器地址栏也会变成新的相对URL。但是，浏览器并不会真的向服务器发送请求，即使状态改变之后查询location.href也会返回与地址栏中相同的地址。第一个参数尽可能地提供初始化页面状态所需的各种信息，第二个参数目前还没有浏览器实现，因此可以只传入一个空字符串。</p><p><pre><code><br> history.pushState({name:’hu1’},’’,”hu.html”);<br></code></pre><br>按下后退按钮，会触发window对象的poststate事件。poststate事件的时间对象有一个state属性，这个属性就包含着当初以第一个参数传递给pushState()的状态对象。</p><p><pre><code><br>EventUtil.addHandler(window,”popstate”,function(event){<br>      var state=event.state;<br>      if(state){<br>          processState(state);<br>      }<br>  })<br></code></pre><br>要更新当前的状态，可以调用replaceState()。调用这个方法不会在历史状态栈中创建新状态，只会重写当前的状态。</p><p><pre><code><br>history.replaceState({name:’hu’},’’)<br></code></pre></p><hr><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;javascript学习16章（HTML5脚本编程）&quot;&gt;&lt;a href=&quot;#javascript学习16章（HTML5脚本编程）&quot; class=&quot;headerlink&quot; title=&quot;javascript学习16章（HTML5脚本编程）&quot;&gt;&lt;/a&gt;&lt;center&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>javascript学习之三</title>
    <link href="http://yoursite.com/2018/09/12/javascript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%89/"/>
    <id>http://yoursite.com/2018/09/12/javascript学习之三/</id>
    <published>2018-09-12T07:02:57.000Z</published>
    <updated>2018-09-14T07:14:10.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="javascript学习15章（使用canvas绘图）"><a href="#javascript学习15章（使用canvas绘图）" class="headerlink" title="javascript学习15章（使用canvas绘图）"></a><center>javascript学习15章（使用canvas绘图）</center></h3><hr><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><pre><code>    var drawing=document.getElementById("drawing");     //确定浏览器是否支持canvas元素     if(drawing.getContext){         var context=drawing.getContext("2d");     }</code></pre><p>使用toDataURL()方法，可以导出在canvas上绘制的图像。这个方法接受一个参数，即图像的MIME类型格式，而且是用于创建图像的任何上下文。<br><code>var imageUrl=drawing.toDataURL(&quot;img/png&quot;)</code></p><hr><h4 id="2D上下文"><a href="#2D上下文" class="headerlink" title="2D上下文"></a>2D上下文</h4><p>2D上下文的坐标开始于canvas元素的左上角，原点坐标是（0，0）.所有坐标值都基于这个原点计算，x越大表示越靠右，y越大表示越靠下。默认情况下，width和height表示水平和垂直2个方向上的可用元素数目。</p><h5 id="填充和描边"><a href="#填充和描边" class="headerlink" title="填充和描边"></a>填充和描边</h5><h5 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h5><pre><code>// *************绘制矩形*******************  // 绘制红色矩形  context.fillStyle="#ff0000";  context.fillRect(10,10,50,50);  // 绘制蓝色半透明矩形  context.fillStyle="rgba(0,0,255,0.5)";  context.fillRect(30,30,50,50);  //清除两个矩形重叠地方的小矩形  context.clearRect(40,40,10,10)  // 绘制红色描边矩形  context.strokeStyle="#ff0000";  context.strokeRect(110,110,50,50);  // 绘制蓝色半透明描边矩形  context.strokeStyle="rgba(0,0,255,0.5)";  context.strokeRect(130,130,50,50);</code></pre><h5 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h5><p>首先必须要调用beginPath()方法,表示要开始绘制新路径</p><ul><li>arc(x,y,radius,startAngle,endAngle,counterclockwise):以x,y为圆心绘制一条圆弧,弧线半径为radius,起始和结束角度分别是startAngle,endAngle.最后一个参数表示startAngle,endAngle是否按照逆时针方向计算,值为false表示按顺时针方向计算.</li><li>arcTo(x1,y1,x2,y2,radius):从上一点绘制一条弧线,到(x2,y2)为止,并以给定的半径radius穿过(x1,y1)</li><li>bezierCurveTo(c1x,c1y,c2x,c2y,x,y):从上一点开始绘制一条曲线,到(x,y)为止,并且以(c1x,c1y)和(,c2x,c2y)为控制点</li><li>lineTo(x,y):从上一点开始绘制一条直线,到(x,y)为止</li><li>moveTo(x,y):将绘画游标移动到(x,y),不画线</li><li>quadraticCurveTo(cx,cy,x,y):从上一点开始绘制一条二次曲线,到(x,y)为止,并且以(cx,cy)作为控制点.</li><li>rect(x,y,width,height):从点(x,y)开始绘制一个矩形,高度分别由width,height指定.<br>如果想绘制一条连接到路径起点的线条，可以调用closePath()<br>填充:fill()<br>路径描边：stroke()<br>路径上创建剪切区域：clip()<br><pre><code><br>//<strong><strong><strong>*</strong></strong></strong>绘制一个不带数字的时钟<strong><strong><strong><strong>***</strong></strong></strong></strong><br>//开始路径<br>context.beginPath();<br>//开始绘制外圆<br>context.arc(100,100,99,0,2<em>Math.PI,false);<br>//绘制内圆<br>context.moveTo(194,100);<br>context.arc(100,100,94,0,2</em>Math.PI,false);<br>//绘制分针<br>context.moveTo(100,100);<br>context.lineTo(100,15);<br>//绘制时针<br>context.moveTo(100,100);<br>context.lineTo(35,100);<br>// 描边路径<br>context.strokeStyle=”#000”;<br>context.stroke();<br></code></pre><h5 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h5><blockquote><p>主要有2个方法:fillText()和strokeText().这2个方法都可以接收4个参数:要绘制的文本字符串,x坐标,y坐标和可选的最大像素宽度.</p></blockquote></li></ul><p>有以下属性:</p><ul><li>font:样式,大小及字体</li><li>textAlign:文本对齐方式,值有”start”,”end”,”left”,”right”和”center”</li><li>textBaseline:文本基线,值有top,hanging,middle,alphabetic,ideographic,bottom</li></ul><pre><code>context.font="bold 14px Arial";context.textAlign="center";context.textBaseline="middle";context.fillText("3",188,100)context.fillText("6",100,188)context.fillText("9",12,100)context.fillText("12",100,12)// measureText(),返回接受文本的width属性var fontSize=100;context.font=fontSize+"px Arial";while(context.measureText("hello world").width > 140){    fontSize--;    context.font=fontSize+"px Arial";}context.fillText("hello world",210,210);context.fillText("font size is"+fontSize,210,250);</code></pre><h5 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h5><p>可以通过如下方法来修改变换矩阵</p><ul><li>rotate(angle): 弧度</li><li>scale(scaleX,scaleY):缩放图像,在x方向乘以scaleX,在y方向上乘以scaleY</li><li>translate(x,y):将坐标原点移动到(x,y).执行这个变换之后,坐标(0,0)会变成*之前由(x,y)</li><li>transform(m1_1,m1_2,m2_1,m2_2,dx,dy):直接修改矩阵,方式是乘以以下矩阵.<br>m1_1  m1_2  dx<br>m2_1  m2_2  dy<br>0     0     1</li><li>setTransform(m1_1,m1_2,m2_1,m2_2,dx,dy):将变换矩阵重置为默认状态,然后再调用transform()</li></ul><p>save():调用这个方法后，当时所有的设置都会进入一个栈结构，得以妥善保管。<br>restore():在保存设置的栈结构中向前返回一级</p><h5 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h5><blockquote><p>drawImage():把一幅图像绘制到画布上,总共需要传入9个参数：要绘制的图像、源图像的x坐标、源图像的y坐标、源图像的宽度、源图像的高度、目标图像的x坐标、目标图像的y坐标、目标图像的宽度、目标图像的高度。</p></blockquote><pre><code>var image=document.images[0];image.onload=function(){    context.drawImage(image,10,10);    context.drawImage(image,50,10,20,30);    context.drawImage(image, 0, 10, 150, 150, 0, 100, 100, 100);}</code></pre><h5 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h5><ul><li>shadowColor: 用css颜色格式表示的阴影颜色，默认是黑色</li><li>shadowOffsetX: 形状或路径x轴方向的阴影偏移量，默认为0</li><li>shadowOffsetY: 形状或路径y轴方向的阴影偏移量，默认为0</li><li>shadowBlur: 模糊的像素数，默认0，即不模糊</li></ul><pre><code>// 设置阴影context.shadowOffsetX=5;context.shadowOffsetY=5;context.shadowBlur=4;context.shadowColor="rgba(0,0,0,0.5)";</code></pre><h5 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h5><p> 要创建一个新的线性渐变:<br> ① 可以调用createLinearGradient()方法。这个方法接受4个参数:起点x坐标，起点的y坐标，终点的x坐标，终点的y坐标。<br> ② 使用addColorStop()方法来指定色标。这个方法接收两个参数：色标位置和css颜色值。色标位置是0（开始的颜色）和1（结束的位置）之间的数字</p><pre><code>var gradient=context.createLinearGradient(230,230,270,270);gradient.addColorStop(0,"white");gradient.addColorStop(1,"black");context.fillStyle=gradient;context.fillRect(230,230,50,50);</code></pre><p>要创建径向渐变（或放射性渐变）<br>① 可以调用createRadialGradient()方法。这个方法接受6个参数,对应2个圆的圆心和半径。<br>② 使用addColorStop()方法来指定色标。这个方法接收两个参数：色标位置和css颜色值。色标位置是0（开始的颜色）和1（结束的位置）之间的数字</p><pre><code>var gradient1=context.createRadialGradient(555,555,10,550,550,30);gradient1.addColorStop(0,"white");gradient1.addColorStop(1,"black");context.fillStyle=gradient1;context.fillRect(530,530,50,50);</code></pre>##### 模式 #####>其实是重复的图像，可以用来填充或描边图形。要创建一个模式，可以调用createPattern()方法并传入两个参数：一个HTML<img>元素和一个表示如何重复的字符串。 *** createPattern()方法的第一个参数也可以是vedio和canvas元素 ***<pre><code>var pattern=context.createPattern(image,"repeat");context.fillStyle=pattern;context.fillRect(10,10,300,300);</code></pre><h5 id="使用图像数据"><a href="#使用图像数据" class="headerlink" title="使用图像数据"></a>使用图像数据</h5><blockquote><p>2D上下文的长处是，可以通过getImageData()取得原始图像的数据。这个方法接受4个参数：要取得其数据的画面区域的x和y坐标以及该区域的像素宽度和高度。</p></blockquote><p><code>var imageData=context.getImageData(10,5,50,50);</code></p><h5 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h5><ul><li>globalAlpha: 是一个介于0和1之间的值，用于指定所有绘制的透明度</li><li>globalCompositionOperation:表示后绘制的图形怎样与先绘制的图形结合</li></ul><hr><h4 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h4><h5 id="类型化数组"><a href="#类型化数组" class="headerlink" title="类型化数组"></a>类型化数组</h5><blockquote><p>类型化数组的核心就是一个名为ArrayBuffer的类型。每个ArrayBuffer对象表示的只是内存中指定的字节数，但不会指定这些字节用于保存什么类型的数据。</p></blockquote><p><code>var buffer=new ArrayBuffer(20);</code><br>创建ArrayBuffer对象后，能通过该对象获得的信息只有它包含的字节数，方法是访问其byteLength<br><code>var bytes=buffer.byteLength</code></p><ul><li>视图<br>使用ArrayBuffer的一种特别的方式就是用它来创建数组缓冲器视图。<br>其中最常见的视图是DataView,通过它可以选择ArrayBuffer中的一小段字节。为此，可以在创建的DataView实例的时候传入一个ArrayBuffer、一个可选的字节偏移量和一个可选的要选择的字节数。<pre><code>//基于整个缓冲器创建一个新视图var view = new DataView(buffer);//创建一个开始于字节9的新视图var view = new DataView(buffer,9);//创建一个字节9开始到字节18的新视图var view = new DataView(buffer,9,10);</code></pre></li><li>类型化视图</li></ul><h5 id="webGL上下文"><a href="#webGL上下文" class="headerlink" title="webGL上下文"></a>webGL上下文</h5><p>（看的比较迷，暂时放弃）</p><ul><li>常量</li><li>方法命名<blockquote><p>方法名的后缀会包含参数个数（1到4）和接收的数据类型（f表示浮点数，i表示整数）。例如，gl.uniform4i意味着要接收4个浮点数。也有很多方法接收数组参组参数，这样的方法其名字中会包含字母v。因此，gl.uniform3iv会包含3个值的整数数组。</p></blockquote></li><li>准备绘图</li><li>视口与坐标</li><li>缓冲区</li><li>错误</li><li>着色器</li><li>编写着色器</li><li>编写着色器程序</li><li>为着色器传入值</li><li>调试着色器和程序</li><li>绘图</li><li>纹理</li><li>读取像素<h5 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h5></li></ul><hr><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;javascript学习15章（使用canvas绘图）&quot;&gt;&lt;a href=&quot;#javascript学习15章（使用canvas绘图）&quot; class=&quot;headerlink&quot; title=&quot;javascript学习15章（使用canvas绘图）&quot;&gt;&lt;/a&gt;&lt;cent
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>javascript学习之二</title>
    <link href="http://yoursite.com/2018/09/06/javascript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/09/06/javascript学习之二/</id>
    <published>2018-09-06T05:30:00.000Z</published>
    <updated>2018-09-12T06:42:57.480Z</updated>
    
    <content type="html"><![CDATA[<h3 id="javascript学习14章（表单的基础知识）"><a href="#javascript学习14章（表单的基础知识）" class="headerlink" title="javascript学习14章（表单的基础知识）"></a><center>javascript学习14章（表单的基础知识）</center></h3><h4 id="表单的基础知识"><a href="#表单的基础知识" class="headerlink" title="表单的基础知识"></a>表单的基础知识</h4><p>在HTML中，表单是由form元素来表示的，而在JavaScript中。表单对应的则是HTMLForm-Element类型。</p><p>取得form元素引用的方式</p><ul><li>添加id属性，然后用getElementById()获取</li><li>通过document.forms可以获取页面中的所有的表单。在这个集合中，可以通过索引或name来取得特定的表单<br><code>var firstForm = document.forms[0]</code>hexo<br><code>var myForm = document.forms[&quot;form2&quot;]</code></li><li><del>~通过document.form2可以访问到名为form2的表单。不过不推荐</del>~</li></ul><h5 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h5><p>只要我们点击一下代码生成的按钮，就可以提交表单<br><code>&lt;input type=&quot;submit&quot; value=&quot;Submit Form&quot;/&gt;</code><br><code>&lt;button type=&quot;submit&quot;&gt;Submit Form&lt;/button&gt;</code><br><code>&lt;input type=&quot;image&quot; src=&quot;graphic.gif&quot;/&gt;</code><br><br><br>为了避免重复提交表单</p><ul><li>在第一次提交表单后就禁用提交按钮</li><li>利用onsubmit事件处理程序取消后续的表单操作</li></ul><h5 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h5><p>当用户单击重置按钮时，表单会被重置。使用 type 特性值为”reset”的input或button都可以创建重置按钮<br><code>&lt;input type=&quot;reset&quot; value=&quot;Reset Form&quot;/&gt;</code><br><code>&lt;button type=&quot;reset&quot;&gt;Reset Form&lt;/button&gt;</code></p><h5 id="表单字段"><a href="#表单字段" class="headerlink" title="表单字段"></a>表单字段</h5><blockquote><p>每个表单都有elements属性，该属性是表单中所有表单元素（字段）的集合，可以按照位置和name的特性来访问它们。</p></blockquote><ul><li>共有的表单字段属性</li><li>共有的表单字段方法：focus()和blur()</li><li>共有的表单字段事件</li></ul><hr><h4 id="文本框脚本"><a href="#文本框脚本" class="headerlink" title="文本框脚本"></a>文本框脚本</h4><h5 id="选择文本"><a href="#选择文本" class="headerlink" title="选择文本"></a>选择文本</h5><blockquote><p>用于选择文本框中的所有文本。</p></blockquote><ul><li>选择（select）事件</li><li>取得选择的文本<blockquote><p>添加2个属性：selectionStart和selectionEnd</p></blockquote></li><li>选择部分文本<blockquote><p>选择文本框中的部分文档：setSelectionRange()<br>IE8及之前版本:</p></blockquote><pre><code><br>   var range=textBox.createTextRange();<br>   range.collapse(true);<br>   range.moveStart(“character”,0);<br>   range.moveEnd(“character”,3);<br>   range.select()<br></code></pre><h5 id="过滤输入"><a href="#过滤输入" class="headerlink" title="过滤输入"></a>过滤输入</h5></li><li>屏蔽字符</li><li>操作剪贴板</li></ul><h5 id="自动切换焦点"><a href="#自动切换焦点" class="headerlink" title="自动切换焦点"></a>自动切换焦点</h5><h5 id="HTML5约束验证API"><a href="#HTML5约束验证API" class="headerlink" title="HTML5约束验证API"></a>HTML5约束验证API</h5><ul><li>必填字段(required)</li><li>其他输入类型（url,email,number,range,datatime,datatime-local,date,month,week,time）</li><li>数值范围(min,max,step)</li><li>输入模式 (pattern属性)</li><li>检测有效性（checkValidity）\</li><li>禁用验证<blockquote><p>通过设置novalidate属性，可以告诉表单不进行验证，如果存在多个提交按钮，为了指定某个提交按钮不需要验证表单，可以在相应的按钮上添加formnovalidate属性。</p></blockquote></li></ul><hr><h4 id="选择框脚本"><a href="#选择框脚本" class="headerlink" title="选择框脚本"></a>选择框脚本</h4><blockquote><p>选择框是通过select和option元素组成的。除了所有表单共有的属性和方法以外，HTMLSelectElement类型还提供了下列属性和方法。</p><ul><li>add</li><li>multiple</li><li>remove</li><li>selectIndex</li><li>size</li></ul></blockquote><h5 id="选择选项"><a href="#选择选项" class="headerlink" title="选择选项"></a>选择选项</h5><h5 id="添加选项"><a href="#添加选项" class="headerlink" title="添加选项"></a>添加选项</h5><ul><li>方法1<pre><code>var newOption=document.createElement("option");newOption.appendChild(document.createTextNode("option text"));newOption.setAttribute("value","Option value");selectBox.appendChild(newOption);</code></pre></li><li><p>方法2</p><pre><code>var newOption2=new Option("newOption2","newOption2 Value");selectBox.appendChild(newOption2)  //在IE8及之前版本中有问题</code></pre></li><li><p>方法3(最佳实践)<br><pre><code><br>var newOption3=new Option(“newOption3”,”newOption3 Value”);<br>selectBox.add(newOption3,undefined)  //最佳实践<br></code></pre></p><h5 id="移除选项"><a href="#移除选项" class="headerlink" title="移除选项"></a>移除选项</h5></li><li>removeChild()</li><li>remove()</li><li>设置为null<h5 id="移动和重排选项"><a href="#移动和重排选项" class="headerlink" title="移动和重排选项"></a>移动和重排选项</h5><blockquote><p>使用DOM中的appendChild方法，就可以将第一个选择框中的选项直接移动到第二个选择框中。</p></blockquote></li></ul><hr><h4 id="表单序列化"><a href="#表单序列化" class="headerlink" title="表单序列化"></a>表单序列化</h4><p><strong> 浏览器是如何将数据发送给服务器的 </strong></p><ul><li>对表单字段的名称和值进行url编码，使用和号（&amp;）分隔</li><li>不发送禁用的表单字段</li><li>只发送勾选的复选框和单选按钮</li><li>多选选择框中每个选中的值单独一个条目</li><li>在单击提交按钮提交表单的情况下，也会发送提交按钮；否则不发送提交按钮，也包括type为image的input元素</li><li>select元素的值，就是选中option的value值。如果option元素没有value特性，则是option元素的文本值。</li></ul><hr><h4 id="富文本编辑"><a href="#富文本编辑" class="headerlink" title="富文本编辑"></a>富文本编辑</h4><blockquote><p>这一技术的本质，就是在页面中嵌入一个包含空HTML页面的iframe.通过设置designMode属性，这个空白的HTML页面可以编辑。而编辑对象则是该页面的body元素的HTML代码。</p></blockquote><h5 id="使用contenteditable属性"><a href="#使用contenteditable属性" class="headerlink" title="使用contenteditable属性"></a>使用contenteditable属性</h5><blockquote><p>可以把contenteditable属性应用给也页面中的任何元素，然后用户立即就可以编辑该元素。有三个可能的值：“true”表示打开，“false”表示关闭，“inherit”表示从父元素那里继承。</p></blockquote><h5 id="操作富文本"><a href="#操作富文本" class="headerlink" title="操作富文本"></a>操作富文本</h5><blockquote><p>主要方式使用document.execCommand()。传递三个参数：要执行的命令名称、表示浏览器是否该为当前命令提供用户界面的一个布尔值（为了确保跨浏览器的兼容性，应该始终设置为false）和执行命令必须的一个值（如不需要传值，则传递null）</p></blockquote><h5 id="富文本选区"><a href="#富文本选区" class="headerlink" title="富文本选区"></a>富文本选区</h5><blockquote><p>使用框架的getSelection()方法，可以确定实际选择的文本</p></blockquote><h5 id="表单与富文本"><a href="#表单与富文本" class="headerlink" title="表单与富文本"></a>表单与富文本</h5><hr><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;javascript学习14章（表单的基础知识）&quot;&gt;&lt;a href=&quot;#javascript学习14章（表单的基础知识）&quot; class=&quot;headerlink&quot; title=&quot;javascript学习14章（表单的基础知识）&quot;&gt;&lt;/a&gt;&lt;center&gt;javasc
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>javascript学习之一</title>
    <link href="http://yoursite.com/2018/08/28/javascript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%80/"/>
    <id>http://yoursite.com/2018/08/28/javascript学习之一/</id>
    <published>2018-08-28T02:49:04.000Z</published>
    <updated>2018-09-05T10:59:46.927Z</updated>
    
    <content type="html"><![CDATA[<h3 id="javascript学习13章（事件）"><a href="#javascript学习13章（事件）" class="headerlink" title="javascript学习13章（事件）"></a><center>javascript学习13章（事件）</center></h3><h4 id="基本释义"><a href="#基本释义" class="headerlink" title="基本释义"></a>基本释义</h4><p><strong>JavaScript</strong>与<strong>HTML</strong>之间的交互是通过<strong>事件</strong>实现的。<br><strong>事件:</strong>就是文档或浏览器窗口发生的一些特定的交互瞬间<br><strong>侦听器</strong>预定事件</p><hr><h4 id="时间流"><a href="#时间流" class="headerlink" title="时间流"></a>时间流</h4><blockquote><p>描述是从页面中接收时间的顺序</p></blockquote><p><strong>IE</strong> 的时间流是 <strong>事件冒泡</strong><br><strong>Netscape Communicator</strong> 的时间流是 <strong>事件捕获</strong></p><h5 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h5><blockquote><p>事件开始时由具体的元素（文档中嵌套最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p></blockquote><p><strong><em>所有现代浏览器都支持事件冒泡。IE5.5及更早的版本中的事件冒泡会跳过<html>元素（从body直接跳到document）。IE9、Firefox、chrome和safari则将事件一直冒泡到windows对象</html></em></strong></p><h5 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h5><blockquote><p>事件捕获的思想是不太具体的节点应该更早接收到事件，而具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达目标之前捕获它。</p></blockquote><h5 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h5><blockquote><p>时间流包括3个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段</p></blockquote><hr><h4 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h4><p><strong>事件：</strong>用户或浏览器自身执行的某种动作<br><strong>click</strong>、<strong>load</strong>和<strong>mouse</strong>，都是事件的名字，而相应某种事件的函数就叫做<strong>事件处理程序</strong></p><h5 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h5><h5 id="DOM0-级事件处理程序"><a href="#DOM0-级事件处理程序" class="headerlink" title="DOM0 级事件处理程序"></a>DOM0 级事件处理程序</h5><blockquote><p>就是将一个函数赋值给一个事件处理程序属性(例如onClick)</p></blockquote><h5 id="DOM2-级事件处理程序"><a href="#DOM2-级事件处理程序" class="headerlink" title="DOM2 级事件处理程序"></a>DOM2 级事件处理程序</h5><blockquote><p>定义了两个方法，用于处理制定和删除事件处理程序的操作：addEventLister()和removeEventLister()。<br>接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值（布尔值为true,表示在捕获阶段调用事件处理程序；如果为false,表示在冒泡阶段调用事件处理程序）</p></blockquote><h5 id="IE-级事件处理程序"><a href="#IE-级事件处理程序" class="headerlink" title="IE 级事件处理程序"></a>IE 级事件处理程序</h5><blockquote><p>提供了类似的两个方法：attachEvent()和detachEvent()。<br>接受2个参数：事件处理程序名称和事件处理程序函数</p></blockquote><p><strong><em>在使用attachEvent()方法的情况下，事件处理程序会在全局作用中运行，因此this等于window</em></strong></p><h5 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h5><blockquote><p>使用EventUtil中addHandler()和removeHandler()<br>传入3个参数：要操作的元素、事件名称和事件处理程序</p></blockquote><p><pre><br>    <code><br>        var EventUtil={<br>           addHandler:function(element,type,handler){<br>               if(element.addEventListener){<br>                   element.addEventListener(type,handler,false)<br>               }else if(element.attachEvent){<br>                   element.attachEvent(“on”+type,handler)<br>               }else{<br>                   element[‘on’+type]=handler<br>               }<br>           },<br>           removeHandler:function(element,type,handler){<br>               if(element.removeEventListener){<br>                   element.addEventListener(type,handler,false)<br>               }else if(element.attachEvent){<br>                   element.detachEvent(“on”+type,handler)<br>               }else{<br>                   element[‘on’+type]=null<br>               }<br>           }<br>       };<br>    </code><br></pre></p><hr><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><h5 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h5><ul><li>所有事件都有下表列出的成员</li></ul><table><thead><tr><th style="text-align:center">属性/方法</th><th style="text-align:center">类型</th><th style="text-align:center">读/写</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">bubbles</td><td style="text-align:center">Boolean</td><td style="text-align:center">只读</td><td style="text-align:center">表明事件是否冒泡</td></tr><tr><td style="text-align:center">cancelable</td><td style="text-align:center">Boolean</td><td style="text-align:center">只读</td><td style="text-align:center">表明是否可以取消事件的默认行为</td></tr><tr><td style="text-align:center">currentTarget</td><td style="text-align:center">Boolean</td><td style="text-align:center">只读</td><td style="text-align:center">其事件处理程序当前正在处理事件的那个元素</td></tr><tr><td style="text-align:center">defaultPrevented</td><td style="text-align:center">Boolean</td><td style="text-align:center">只读</td><td style="text-align:center">为true表示已经调用了preventDefault()</td></tr><tr><td style="text-align:center">detail</td><td style="text-align:center">Integer</td><td style="text-align:center">只读</td><td style="text-align:center">与事件相关的细节信息</td></tr><tr><td style="text-align:center">evenPhase</td><td style="text-align:center">Integer</td><td style="text-align:center">只读</td><td style="text-align:center">调用事件处理程序的阶段：1表示捕获阶段，2表示“处于目标”，3表示冒泡阶段</td></tr><tr><td style="text-align:center">preventDefault</td><td style="text-align:center">Function</td><td style="text-align:center">只读</td><td style="text-align:center">取消事件的默认行为。如果cancelable是true,则可以使用这个方法</td></tr><tr><td style="text-align:center">stopImmediatePropagation</td><td style="text-align:center">Function</td><td style="text-align:center">只读</td><td style="text-align:center">取消事件的进一步捕获或者冒泡，同时阻止任何事件处理程序被调用(DOM3级重新增)</td></tr><tr><td style="text-align:center">stopPropagation</td><td style="text-align:center">Function</td><td style="text-align:center">只读</td><td style="text-align:center">取消事件进一步的捕获或者冒泡。如果bubbles为true,则可以使用这个方法</td></tr><tr><td style="text-align:center">target</td><td style="text-align:center">Element</td><td style="text-align:center">只读</td><td style="text-align:center">事件的目标</td></tr><tr><td style="text-align:center">trusted</td><td style="text-align:center">Boolean</td><td style="text-align:center">只读</td><td style="text-align:center">为true表示事件是浏览器生成的。为false表示是由开发人员通过javascript创建的（DOM3级事件中新增）</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">String</td><td style="text-align:center">只读</td><td style="text-align:center">被触发的事件类型</td></tr><tr><td style="text-align:center">view</td><td style="text-align:center">Abstractive</td><td style="text-align:center">只读</td><td style="text-align:center">与事件关联的抽象视图。等同于发生事件的window对象</td></tr></tbody></table><p><strong><em>只用在事件处理程序执行期间，event对象才会存在；一旦事件处理程序执行完毕，event对象就会被销毁</em></strong></p><hr><h5 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h5><p>在要访问IE中event对象有几种不同的方式，取决于指定事件处理程序的方法。</p><ul><li>在使用DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性</li><li>如果是使用attachEvent()添加的，那么就会有一个event对象作为参数被传入事件处理程序函数中（也可以通过window对象来访问event对象）</li><li>通过HTML特性指定的事件处理程序，那么还可以通过一个名叫event的变量来访问event对象<br><code>&lt;input type=&#39;button&#39; value=&#39;Click me&#39; onclick=&#39;alert(event.type)&#39;/&gt;</code></li></ul><table><thead><tr><th style="text-align:center">属性/方法</th><th style="text-align:center">类型</th><th style="text-align:center">读/写</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">cancelBubble</td><td style="text-align:center">Boolean</td><td style="text-align:center">读/写</td><td style="text-align:center">默认值为false，将其设置为true就可以取消事件冒泡（与DOM中stopPropagation()方法的作用相同）</td></tr><tr><td style="text-align:center">returnValue</td><td style="text-align:center">Boolean</td><td style="text-align:center">读/写</td><td style="text-align:center">默认值为true,但将其设置为false就可以取消事件的默认行为（与DOM中preventDefalut()方法的作用相同）</td></tr><tr><td style="text-align:center">srcElement</td><td style="text-align:center">Element</td><td style="text-align:center">只读</td><td style="text-align:center">事件的目标</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">String</td><td style="text-align:center">只读</td><td style="text-align:center">被触发的事件类型</td></tr></tbody></table><hr><h5 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h5><p><pre><br>    <code><br>        var EventUtil={<br>                addHandler:function(element,type,handler){<br>                    // 省略代码<br>                },<br>                getEvent:function(event){<br>                    return evnet?event:window.event<br>                },<br>                getTarget:function(event){<br>                    return event.target || event.srcElement<br>                },<br>                preventDefault:function (event) {<br>                    if(event.preventDefault){<br>                        event.preventDefault()<br>                    }else{<br>                        event.returnValue=false;<br>                    }<br>                },<br>                removeHandler:function(element,type,handler){<br>                    //省略代码<br>                },<br>                stopPropagation:function(event){<br>                    if(event.stopPropagation){<br>                        event.stopPropagation();<br>                    }else{<br>                        event.cancelBubble=true<br>                    }<br>                }<br>            }<br>    </code><br></pre></p><hr><h4 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h4><p>“DOM3级事件”规定了以下几类事件类型</p><ul><li>UI事件，当用户与页面上的元素交互时触发</li><li>焦点事件，当用户获得或失去焦点时触发</li><li>鼠标事件，当用户通过鼠标在页面上执行操作时触发</li><li>滚轮事件，当使用鼠标滚轮（或类似设备时）触发</li><li>文本事件，当在文档中输入文本时触发</li><li>键盘事件，当用户通过键盘在页面上执行操作时触发</li><li>合成事件，当为IME(Input Medthod Editor,输入法编辑器)输入字符时触发</li><li>变动事件，当底层DOM结构发生变化时触发</li><li><del>变动名称事件，当元素或者属性名变动时触发，已经废弃</del></li></ul><h5 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h5><ul><li>load事件</li><li>unload事件</li><li>resize事件<br><strong><em>浏览器窗口最小化最大化也会触发resize事件</em></strong></li><li>scroll事件</li></ul><h5 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h5><ul><li>blur</li><li>DOMFocusIn</li><li>DOMFocusOut</li><li>focus</li><li>focusin</li><li>focusout</li></ul><h5 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h5><p>DOM3级中定义了9个鼠标事件</p><ul><li>click</li><li>dbclick</li><li>mousedown</li><li>mouseenter: 在鼠标光标从元素外部首次移到元素范围之内时触发</li><li>mouseleave: 在位于元素上方的鼠标移动到元素范围之外时触发</li><li>mousemove: 当鼠标在元素内部移动时反复的触发</li><li>mouseout： 在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发</li><li>mouseover：在鼠标指针位于一个元素的外部，然后用户将其首次移入另外一个元素边界之内触发</li><li>mouseup</li></ul><ul><li><p>1.客户区坐标位置</p><blockquote><p>鼠标事件都是在浏览器视口中的特定位置上发生的。这个位置信息保存在事件对象的clientX和clientY属性中。</p></blockquote></li><li><p>2.页面坐标位置</p><blockquote><p>这个位置信息保存在事件对象的pageX和pageY属性中。</p></blockquote></li><li><p>3.屏幕坐标位置</p><blockquote><p>这个位置信息保存在事件对象的screenX和screenY属性中。</p></blockquote></li><li><p>4.修改键</p></li><li><p>5.相关元素</p></li><li>6.鼠标按钮</li><li><p>7.更多的事件信息</p><blockquote><p>对于鼠标事件来说，detail中包含一个数值，表示在给定的位置上发生多少次点击</p></blockquote></li><li><p>8.鼠标滚轮事件</p></li><li>9.触摸设备</li><li>10.无障碍性问题</li></ul><h5 id="键盘与文本事件"><a href="#键盘与文本事件" class="headerlink" title="键盘与文本事件"></a>键盘与文本事件</h5><p>有3个键盘事件</p><ul><li>keydown：在键盘上按下任何键触发，可重复触发</li><li>keypress: 在键盘上按下数字键触发，可重复触发</li><li>keyup: 当用户释放键盘上的键时处罚</li><li>textInput:在可编辑区域中输入字符时，就会触发这个事件</li></ul><h5 id="复合事件"><a href="#复合事件" class="headerlink" title="复合事件"></a>复合事件</h5><blockquote><p>用于处理IME的输入序列</p></blockquote><h5 id="变动事件"><a href="#变动事件" class="headerlink" title="变动事件"></a>变动事件</h5><p>能在DOM中某一部分发生变化时给出提示</p><ul><li>DOMSubtreeModified：在DOM结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发</li><li>DOMNodeInserted: 在一个节点作为子节点被插入另一个节点中时触发</li><li>DOMNodeRemoved: 在节点从其父节点中被移除时触发</li><li>DOMNodeInsertedIntoDocument:在一个节点被直接插入文档或通过子树直接插入文档之后触发。这个事件在DOMNodeInserted之后触发</li><li>DOMNodeRemovedFromDocument:在一个节点被直接从文档中移除或通过子树间接从文档中移除之前触发。这个事件在DOMNodeRemoved之后触发</li><li>DOMAtrrModified：在特性被修改之后触发</li><li>DOMChracterDataModified:在文本节点的值发生变化时触发。</li></ul><h5 id="HTML5事件"><a href="#HTML5事件" class="headerlink" title="HTML5事件"></a>HTML5事件</h5><ul><li>contextmenu事件<blockquote><p>用以表示何时应该显示上下文菜单，以便开发人员取消默认的上下文菜单而提供自定义的菜单</p></blockquote></li><li>beforeunload事件<blockquote><p>是为了让开发人员有可能在页面卸载之前阻止这一操作</p></blockquote></li><li>DOMContentLoaded事件<blockquote><p>window的load事件会在页面中的一切都加载完毕时触发，但这个过程可能会因为要加载外部资源过多而颇费周折。DOMContentLoaded事件则在形成完整的DOM树之后就会触发，不理会图像，JavaScript文件、css文件或其他资源是否下载完毕。</p></blockquote></li><li>readystatechange事件<blockquote><p>提供与文档或元素的加载状态有关的信息</p></blockquote></li><li>pageshow和pagehide事件</li><li>hashChange事件<blockquote><p>以便URL的参数列表发生变化时通知开发人员</p></blockquote></li></ul><h5 id="设备事件"><a href="#设备事件" class="headerlink" title="设备事件"></a>设备事件</h5><ul><li>orientationchange事件<blockquote><p>只要用户改变了设备查看模式，就会触发orientationchange事件   、</p></blockquote></li></ul><p><strong><em> 所有ios设备都支持orientationonchange事件和window.orientation属性</em></strong></p><ul><li>MozOrientation事件<blockquote><p>当设备的加速计检测到设备方向改变时，就会触发这个事件。该事件只能提供一个平面的方向变化。</p></blockquote></li></ul><p><strong><em> 只有带加速器的设备才支持MozOrientation事件</em></strong></p><ul><li>deviceorientation事件</li><li>devicemotion事件</li></ul><h5 id="触摸与手势事件"><a href="#触摸与手势事件" class="headerlink" title="触摸与手势事件"></a>触摸与手势事件</h5><ul><li>触摸事件</li><li>手势事件</li></ul><hr><h4 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h4><h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5><blockquote><p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理一个某一类型的所有事件</p></blockquote><p><strong><em>最适合采用事件委托的事件包括click,mouseup.mousedown,keyup,keydown和keypress</em></strong></p><h5 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h5><h4 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h4><h5 id="DOM中的事件模拟"><a href="#DOM中的事件模拟" class="headerlink" title="DOM中的事件模拟"></a>DOM中的事件模拟</h5><ul><li>模拟鼠标事件</li><li>模拟键盘事件</li><li>模拟其他事件</li><li>自定义DOM事件</li></ul><h5 id="IE中的事件模拟"><a href="#IE中的事件模拟" class="headerlink" title="IE中的事件模拟"></a>IE中的事件模拟</h5><hr><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;javascript学习13章（事件）&quot;&gt;&lt;a href=&quot;#javascript学习13章（事件）&quot; class=&quot;headerlink&quot; title=&quot;javascript学习13章（事件）&quot;&gt;&lt;/a&gt;&lt;center&gt;javascript学习13章（事件）&lt;/
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>网站搭建学习</title>
    <link href="http://yoursite.com/2018/08/24/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/08/24/网站搭建学习/</id>
    <published>2018-08-24T07:42:52.000Z</published>
    <updated>2018-08-24T09:15:55.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h3><pre><code>参考网址：https://yegod.github.io/blog-1/</code></pre><h3 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h3><pre><code>参考网址：https://blog.csdn.net/ganzhilin520/article/details/79047983</code></pre><h3 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a>添加评论功能</h3><pre><code>参考网址：https://blog.csdn.net/lcyaiym/article/details/76762074</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;网站搭建&quot;&gt;&lt;a href=&quot;#网站搭建&quot; class=&quot;headerlink&quot; title=&quot;网站搭建&quot;&gt;&lt;/a&gt;网站搭建&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;参考网址：https://yegod.github.io/blog-1/
&lt;/code&gt;&lt;/pre&gt;&lt;h3 
      
    
    </summary>
    
    
      <category term="伸手党" scheme="http://yoursite.com/tags/%E4%BC%B8%E6%89%8B%E5%85%9A/"/>
    
  </entry>
  
</feed>
